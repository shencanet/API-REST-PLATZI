console.log(Number(2) === Number(2)); //ğŸ¤”?
console.log(Boolean(false) === Boolean(false)); //ğŸ¤”?
console.log(Symbol('foo') === Symbol('foo')); //ğŸ¤”?Respuesta Correcta: A) true, true, false
/*
Primero, usamos el constructor Number para convertir 2 a number, como solo es una conversiÃ³n de primitivos entonces el resultado es true.

Segundo, usamos el constructor Boolean para convertir false a boleano, nuevamente solo es una conversiÃ³n, entonces el resultado de la comparaciÃ³n es true.

Tercero, ningÃºn Symbol es igual a otro Symbol, por mÃ¡s que en el ejemplo tengan los mismos placeholders foo, nunca serÃ¡n iguales. Entonces siempre nos darÃ¡ false.

No debemos confundir el contructor Number y Boolean por sÃ­ mismos, con dichos costructures acompaÃ±ados de la palabra new, si hacemos lo siguiente:

  const a = new Number(2);

 const b = new Boolean(true);  



Ambas variables serÃ¡n objetos creados por medio de estos contructores, y no solo conversiones como en el ejercicio principal de este reto.*/
const one = true || {} || null;
const two = null || 'hello' || '';
const three = 0 || [] || true;
console.log(one, two, three);
/*Respuesta Correcta: B) true "hello" []
Con el operador || "OR", devolvemos el primer valor booleano verdadero "true", si todos los valores son falsos, se devuelve el Ãºltimo valor de la sentencia.

En la constante one: (true || {} || null); su primer valor es verdadero, por lo tanto, retorna true.

En la constante two: (null || "hello" || ""); null es un valor falso "false", la cadena "hello" es un valor verdadero "true", por lo tanto, retornarÃ¡ la cadena "hello" y no evaluarÃ¡ mÃ¡s condiciones.

En la constante three: (0 || [] || true); el valor 0 es un valor falso "false", mientras que el arreglo "array" vacÃ­o es un valor verdadero "true", por lo tanto retornarÃ­a el arreglo vacÃ­o.

Entonces, la salida de este cÃ³digo serÃ­a: (true, "hello", []);*/

function makeMulti(x) {
  return (y) => x * y;
}

const five = makeMulti(5);
const rta = five(6);
console.log(rta);
/*AquÃ­ tenemos el escenario de un closure, un closure es:

- Una funciÃ³n que puede recibir un dato y lo almacena en su scope
- Retorna una funciÃ³n que ocupa ese dato previamente guardado

En este caso estamos haciendo una "fÃ¡brica" de multiplicadores.

// five es una funciÃ³n que tiene guardada en su scope la variable x con el valor de 5
const five = makeMulti(5);

// Ahora podemos pasarle a la funciÃ³n five cualquier valor que queramos multiplicar por 5
const rta = five(6);

// Podemos hacer mÃ¡s funciones multiplicadoras como:
const seven = makeMulti(7);
const two = makeMulti(2); */

let Alimento = function (comida) {
  this.comida = comida;
};

Alimento.prototype.comerHoy = () => console.log('Hoy toca comer:', this.comida);
const alimento = new Alimento('ensalada');

alimento.comerHoy(); //â“
/*Respuesta Correcta: D) Hoy toca comer: undefined
Una de las limitaciones de las funciones flecha (arrow functions), es que no tiene sus propias referencias a this o super y no se debe usar como mÃ©todos.

this siempre apuntarÃ¡ a this desde el contexto en el que definimos la funciÃ³n (ejemplo window).

Por tal razÃ³n, la funciÃ³n flecha () => { ... } no sabe de this.comida*/
const myLifeSummedUp = ["â˜•", "ğŸ’»", "ğŸ·", "ğŸ«"];

for (let item in myLifeSummedUp) {
  console.log('uno');
  console.log(item); //ğŸ¤”?
}

for (let item of myLifeSummedUp) {
  console.log('Dos');
  console.log(item); //ğŸ¤”?
}
/*Respuesta Correcta: A) 0 1 2 3 y "â˜•" "ğŸ’»" "ğŸ·" "ğŸ«"
Con el bucle for-in, podemos iterar sobre propiedades enumerables. Los enumerables en el arreglo son justamente sus Ã­ndices. Por ello es 0 1 2 3.

Con un bucle for-of, podemos recorrer iterables. Un arreglo por definiciÃ³n es un iterable, en cada iteraciÃ³n la variable item es igual al elemento sobre el cual se itera en ese momento. Por ello es "â˜•" "ğŸ’»" "ğŸ·" "ğŸ«".

En la practica los bucles for-of son mÃ¡s usados y ocacionalmente los bucles for-in.*/
function greeting() {
  throw 'Hello world!';
}

function sayHi() {
  try {
    const data = greeting();
    console.log('It worked!', data);
  } catch (e) {
    console.log('Oh no an error!', e);
  }
}

sayHi();
/*La funciÃ³n greeting con la palabra reservada throw genera una excepciÃ³n de tipo string en el cÃ³digo.

La funciÃ³n sayHi consta de una sentencia try...catch, recordemos que si no hay ningÃºn tipo de excepciÃ³n el cÃ³digo ejecuta el bloque try pero como si generamos una excepciÃ³n entonces entramos al bloque catch donde el parÃ¡metro e adopta el valor de la excepciÃ³n, osea, Hello world!. Por eso el resultado es "Oh no an error! Hello world!"*/