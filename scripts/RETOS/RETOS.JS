console.log(Number(2) === Number(2)); //游뱂?
console.log(Boolean(false) === Boolean(false)); //游뱂?
console.log(Symbol('foo') === Symbol('foo')); //游뱂?Respuesta Correcta: A) true, true, false
/*
Primero, usamos el constructor Number para convertir 2 a number, como solo es una conversi칩n de primitivos entonces el resultado es true.

Segundo, usamos el constructor Boolean para convertir false a boleano, nuevamente solo es una conversi칩n, entonces el resultado de la comparaci칩n es true.

Tercero, ning칰n Symbol es igual a otro Symbol, por m치s que en el ejemplo tengan los mismos placeholders foo, nunca ser치n iguales. Entonces siempre nos dar치 false.

No debemos confundir el contructor Number y Boolean por s칤 mismos, con dichos costructures acompa침ados de la palabra new, si hacemos lo siguiente:

  const a = new Number(2);

 const b = new Boolean(true);  



Ambas variables ser치n objetos creados por medio de estos contructores, y no solo conversiones como en el ejercicio principal de este reto.*/
const one = true || {} || null;
const two = null || 'hello' || '';
const three = 0 || [] || true;
console.log(one, two, three);
/*Respuesta Correcta: B) true "hello" []
Con el operador || "OR", devolvemos el primer valor booleano verdadero "true", si todos los valores son falsos, se devuelve el 칰ltimo valor de la sentencia.

En la constante one: (true || {} || null); su primer valor es verdadero, por lo tanto, retorna true.

En la constante two: (null || "hello" || ""); null es un valor falso "false", la cadena "hello" es un valor verdadero "true", por lo tanto, retornar치 la cadena "hello" y no evaluar치 m치s condiciones.

En la constante three: (0 || [] || true); el valor 0 es un valor falso "false", mientras que el arreglo "array" vac칤o es un valor verdadero "true", por lo tanto retornar칤a el arreglo vac칤o.

Entonces, la salida de este c칩digo ser칤a: (true, "hello", []);*/

function makeMulti(x) {
  return (y) => x * y;
}

const five = makeMulti(5);
const rta = five(6);
console.log(rta);
/*Aqu칤 tenemos el escenario de un closure, un closure es:

- Una funci칩n que puede recibir un dato y lo almacena en su scope
- Retorna una funci칩n que ocupa ese dato previamente guardado

En este caso estamos haciendo una "f치brica" de multiplicadores.

// five es una funci칩n que tiene guardada en su scope la variable x con el valor de 5
const five = makeMulti(5);

// Ahora podemos pasarle a la funci칩n five cualquier valor que queramos multiplicar por 5
const rta = five(6);

// Podemos hacer m치s funciones multiplicadoras como:
const seven = makeMulti(7);
const two = makeMulti(2); */